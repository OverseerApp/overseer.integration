using System.Text.Json.Serialization;

namespace Overseer.Server.Integration.Machines;

public class Machine
{
  /// <summary>
  /// The unique identifier of the machine, will be automatically generated by the server when the machine is created.
  /// </summary>
  public int Id { get; set; }

  /// <summary>
  /// The user assigned name of the machine
  /// </summary>
  public string? Name { get; set; }

  /// <summary>
  /// Whether the machine is disabled. Providers for disabled machines will not be loaded.
  /// </summary>
  public bool Disabled { get; set; }

  /// <summary>
  /// The URL of the machine's webcam stream, if available. This can be used by the client to display a live feed from the machine's webcam.
  /// </summary>
  public virtual string? WebcamUrl { get; set; }

  /// <summary>
  /// The orientation of the machine's webcam, if available. This can be used by the client to correctly orient the webcam feed when displaying it.
  /// If not specified, the client should assume a default orientation.
  /// </summary>
  [JsonConverter(typeof(JsonStringEnumConverter))]
  public virtual MachineWebcamOrientation? WebcamOrientation { get; set; }

  /// <summary>
  /// The tools available on the machine, Currently supports "Heater" and "Extruder" tool types.
  /// </summary>
  public IEnumerable<MachineTool> Tools { get; set; } = [];

  /// <summary>
  /// The sort index of the machine, used to determine the order in which machines are displayed in the client.
  /// </summary>
  public int SortIndex { get; set; }

  /// <summary>
  /// A dictionary of custom properties for the machine. This can be used to store additional information about the machine that is not covered by
  /// the other properties. The contents of this dictionary are up to the provider and client to define and interpret, but it can be used to store
  /// things website url, ip address, passwords, or any other relevant information.
  /// </summary>
  public virtual Dictionary<string, object> Properties { get; set; } = [];

  public void SetProperty(string key, object? value)
  {
    if (value == null)
    {
      Properties.Remove(key);
      return;
    }

    Properties[key] = value;
  }

  public T? GetProperty<T>(string key)
  {
    if (Properties.TryGetValue(key, out var value) && value is T typedValue)
    {
      return typedValue;
    }
    return default;
  }
}
